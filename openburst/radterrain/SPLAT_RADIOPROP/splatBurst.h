/**************************************************************************** \
* 	   derived from SPLAT!: An RF Signal Path Loss And Terrain Analysis Tool *
*       to parallelize the computation and to enable usage from Python       *
******************************************************************************
*	       												     			     *
*			  Last update: 22-March-2024								     *
******************************************************************************

******************************************************************************
*                                                                            *
*  This program is free software; you can redistribute it and/or modify it   *
*  under the terms of the GNU General Public License as published by the     *
*  Free Software Foundation; either version 2 of the License or any later    *
*  version.								     *
* 									     *
*  This program is distributed in the hope that it will useful, but WITHOUT  *
*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     *
*  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License     *
*  for more details.							                             *
*									                                         *
\****************************************************************************/


#ifndef SPLAT_H
#define SPLAT_H

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <bzlib.h>
#include <unistd.h>
#include "fontdata.h"

#include <boost/python/numpy.hpp>
#include <boost/python.hpp>

#include <boost/mpi/environment.hpp>
#include <boost/mpi/communicator.hpp>
#include <boost/mpi.hpp>
#include <boost/serialization/string.hpp>

#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/containers/vector.hpp>
#include <boost/interprocess/allocators/allocator.hpp>

#include <boost/python/suite/indexing/vector_indexing_suite.hpp> // necessary to return float vector (see: https://riptutorial.com/boost/example/25280/wrapping-std--vector-in-boost-python)
#include <iostream>
#include <fstream>
#include <string>



/*
  Parameters for 1 arc-second high resolution mode of operation
  Generated by ./configure by radaruser on Mo 27. Apr 16:01:10 CEST 2020
*/

/*
  MAXPAGES HERE can be set to maximally 64, meaning there is a hard limit for coverage computation of around 400km radius!!
  ESPECIALLY RELEVANT to consider this limit for very long range PET Sensors or highly sensitive Radio (Richtfunk) receivers

*/


#define HD_MODE 1
#define MAXPAGES 144 // 287 //144 //64 // 64 is max < 400km Radius


#define GAMMA 2.5
#define BZBUFFER 65536

#if HD_MODE==0
	#if MAXPAGES==4
	#define ARRAYSIZE 4950
	#endif

	#if MAXPAGES==9
	#define ARRAYSIZE 10870
	#endif

	#if MAXPAGES==16
	#define ARRAYSIZE 19240
	#endif

	#if MAXPAGES==25
	#define ARRAYSIZE 30025
	#endif

	#if MAXPAGES==36
	#define ARRAYSIZE 43217
	#endif

	#if MAXPAGES==49
	#define ARRAYSIZE 58813
	#endif

	#if MAXPAGES==64
	#define ARRAYSIZE 76810
	#endif

    #if MAXPAGES==144
	#define ARRAYSIZE 172800
	#endif

	#define IPPD 1200
#endif

#if HD_MODE==1
	#if MAXPAGES==1
	#define ARRAYSIZE 5092 
	#endif

	#if MAXPAGES==4
	#define ARRAYSIZE 14844 
	#endif

	#if MAXPAGES==9
	#define ARRAYSIZE 32600
	#endif

	#if MAXPAGES==16
	#define ARRAYSIZE 57713
	#endif

	#if MAXPAGES==25
	#define ARRAYSIZE 90072
	#endif

	#if MAXPAGES==36
	#define ARRAYSIZE 129650
	#endif

	#if MAXPAGES==49 
	#define ARRAYSIZE 176437
	#endif

	#if MAXPAGES==64
	#define ARRAYSIZE 230430
	#endif

    #if MAXPAGES==144
	#define ARRAYSIZE 518544
	#endif


	#define IPPD 3600
#endif

#ifndef PI
#define PI 3.141592653589793
#endif

#ifndef TWOPI
#define TWOPI 6.283185307179586
#endif

#ifndef HALFPI
#define HALFPI 1.570796326794896
#endif

#define DEG2RAD 1.74532925199e-02
#define EARTHRADIUS 20902230.97
#define	METERS_PER_MILE 1609.344
#define METERS_PER_FOOT 0.3048
#define	KM_PER_MILE 1.609344
#define FOUR_THIRDS 1.3333333333333



int nof_loaded_pages = 0;

char 	string[255], sdf_path[255], opened=0, gpsav=0, splat_name[10],
	splat_version[6], dashes[80], olditm;

double	earthradius, max_range=0.0, forced_erp=-1.0, dpp, ppd,
	fzone_clearance=0.6, forced_freq, clutter;

int	min_north=90, max_north=-90, min_west=360, max_west=-1, ippd, mpi,
	max_elevation=-32768, min_elevation=32768, bzerror, contour_threshold;

unsigned char got_elevation_pattern, got_azimuth_pattern, metric=0, dbm=0, smooth_contours=0;

struct site {	double lat;
		double lon;
		float alt;
		char name[50];
		char filename[255];
	    } 	site;


struct path {	double lat[ARRAYSIZE];
		double lon[ARRAYSIZE];
		double elevation[ARRAYSIZE];
		double distance[ARRAYSIZE];
		int length;
	    }	path;

struct pathBurst {
        double* lat;
		double* lon;
		double* elevation;
		double* distance;
		int length;
	    };

struct dem {	int min_north; // in shared mem for parallelization
		int max_north; // in shared mem for parallelization
		int min_west; // in shared mem for parallelization
		int max_west; // in shared mem for parallelization
		int max_el; // in shared mem for parallelization
		int min_el;// in shared mem for parallelization
		short data[IPPD][IPPD]; // in shared mem for parallelization
		unsigned char mask[IPPD][IPPD];
		unsigned char signal[IPPD][IPPD];
}	dem[MAXPAGES];
  

struct LR {	double eps_dielect; 
		double sgm_conductivity; 
		double eno_ns_surfref;
		double frq_mhz; 
		double conf; 
		double rel;
		double erp;
		int radio_climate;  
		int pol;
		float antenna_pattern[361][1001];
          }	LR;

struct region { unsigned char color[32][3];
		int level[32];
		int levels;
	      }	region;



double elev[ARRAYSIZE+10];

int* dem_attrs_arr; // global array dem attributes
short* dem_arr; // global array dem


// for shared memory (for parallel processing) 
// START BOOST functions 
char burst_dem_path[] = "/home/red3/Downloads/SRTM3_Eurasia_Data/SDF_Files/";

struct ObstructionAnalysisReturn{
    int los; // 0 if no los, 1 if los
    int first_fresnel_zone_clear; // 1 if first fresnel zone clear, 0 otherwise
    float surface_distance; // distance in meters (great circle distance) not including elevating
    float point_to_point_distance; // distance in m from point to point including elevation

};


struct Pt2PtReturn : ObstructionAnalysisReturn {
  float propagation_path_loss; // propagation path loss in dB (elevation considered)
  float free_space_loss; // between the points on the earths surface, no elevation considered
  float source_elevation; // elevation masl of source
  float dest_elevation; // elevation masl of desination

};


namespace bi = boost::interprocess;


/** Generic Shared Memory Allocator */
template<typename T>
using ShmemAllocator = bi::allocator<T, bi::managed_shared_memory::segment_manager> ;

/** Generic STL vector allocated in shared memory */


/** RAII Object for removing shared memory segment. */
struct SharedMemoryCleaner
{	
  std::string m_name;
  SharedMemoryCleaner(std::string name): m_name(name){ }
  
  ~SharedMemoryCleaner(){ // this destructor will be called automatically if a struct is instantiated for each shared memory segment
    namespace bi = boost::interprocess;
    std::cerr << " [INFO] Remove shared memory segment { name = " << m_name << " }" << "\n";
    bi::shared_memory_object::remove(m_name.c_str());
  }
};



auto shm = bi::shared_memory_object{	
        bi::open_or_create,
        "dem_shared_memory_segment",
        bi::read_write
	};
auto shm_remove = SharedMemoryCleaner("dem_shared_memory_segment");


////////// MAKE variable to read mem
auto shm_read = bi::shared_memory_object{
	    bi::open_only, 
	    "dem_shared_memory_segment",
	    bi::read_only
};

////// for dem attrributes : min_north, max_north, min_west, max_west, max_el, min_el (all int)
auto shm_attrs = bi::shared_memory_object{	
        bi::open_or_create,
        "dem_attrs_shared_memory_segment",
        bi::read_write
	};
auto shm_attrs_remove = SharedMemoryCleaner("dem_attrs_shared_memory_segment");

auto shm_attrs_read = bi::shared_memory_object{bi::open_only, 
					       "dem_attrs_shared_memory_segment",
					       bi::read_only
};

////////// MAKE variable to read it
//auto shm_attrs_read = bi::shared_memory_object{
//	    bi::open_only, 
//	    "dem_attrs_shared_memory_segment",
//	    bi::read_only
//};


// the following wil be used for DEM attributes shared memory reading by the instance (in GetElevation)
bi::mapped_region attrs_region_p_site;
void* attrs_pMem_read_p_site;
int* attrs_arr_read_p_site;

// the following wil be used for DEM attributes shared memory reading by the instance (in GetElevation)
bi::mapped_region dem_region_read;
void* dem_pMem_read;
short* dem_arr_read;


unsigned int sizeof_mem_dem_array = 0; // this will be set to the sizeof the shared mem dem array
int sizeof_mem_dem_attrs_array = 0; // this will be set to the sizeof the shared mem dem attrs array



void LoadTopoData(int max_lon, int min_lon, int max_lat, int min_lat);
void PlaceMarker(struct site location);
Pt2PtReturn PathReportBURST(struct site source, struct site destination);
ObstructionAnalysisReturn ObstructionAnalysisBURST(struct site xmtr, struct site rcvr, double f);
double GetElevation(struct site location);
float Distance_including_ELevation(struct site source, struct site destination);
double Distance(struct site source, struct site destination);

double ElevationAngleTwo(struct site source, struct site destination, double er);
double ElevationAngle(struct site source, struct site destination);

class GetLosAndLossReturn{ 
public: 
  std::vector<float> los; // [0/1]
  std::vector<float> loss; // [dB] contains propagation loss from 3D point to 3D point (will be atleast as large as free space loss)
  std::vector<float> free_loss; // [dB] contains free space loss from 3D point to 3D point (will be always less than or equal to propagation loss)
  std::vector<float> dist; // distance [m]


  std::vector<float> readLosMatrix();
  std::vector<float> readLossMatrix();
  std::vector<float> readFreeLossMatrix();
  std::vector<float> readDistMatrix();

  
  
}; 


class prop_site
{
  float tx_lat;
  float tx_lon;
  float tx_alt_agl;
  std::string tx_name;
  float rx_lat;
  float rx_lon;
  float rx_alt_agl;
  std::string rx_name;
  float freq;

  float diel_const;
  float earth_cond;
  float at_bend;
  float radio_climate;
  float pol;
  float frac_of_situ;
  float frac_of_time;
  float ground_clutter;
  int oitm;

  float minlat;
  float maxlat;
  float minlon;
  float maxlon;
  

  
  
public:
  prop_site();  // declare default constructor

  // this will compute LoS, dist, prop-loss and free-space loss (for each lat-lon pairs in the lists at given height), justLos==1 means only LoS and dist will be computed (see test_splat_parallel.py for usage)
  //  set reverseDirection to "1" to compute propagation (and loss) from rx to tx
  GetLosAndLossReturn* getLosAndLossMatrix(float src_lat, float src_lon, float src_alt, boost::python::list& dest_lat_arr, boost::python::list& dest_lon_arr, float dest_alt, float freq, int asl, int nof_processes, int justLos, int reverseDirection);

  // this will compute LoS, dist, prop-loss and free-space loss (for the lat-lon-height given), justLos == 1 mean only LoS and dist are computed and no propagation.
  //  set reverseDirection to "1" to compute propagation (and loss) from rx to tx
  // alts should be given in FEET!!!
  // if justlos == 1 the return is: los, first_fresnel_zone_clear, surface_distance, point_to_point_distance
  // if justlos == 0 the return is: los, propagation_path_loss, free_space_loss, surface_distance, source_elevation, dest_elevation, point_to_point_distance, first_fresnel_zone_clear
  std::vector<float> getLosAndLoss(float tx_lat, float tx_lon, float tx_alt_agl, float rx_lat, float rx_lon, float rx_alt_agl, float freq, int asl, int justLos, int reverseDirection=0);


   std::vector<float> getElevationsMatrix(boost::python::list& dest_lat_arr, boost::python::list& dest_lon_arr);

  // this will compute LoS, dist, prop-loss and free-space loss (for each lat-lon pairs in the lists at given height), justLos==1 means only LoS and dist will be computed (see test_splat_parallel.py for usage)
  GetLosAndLossReturn* getLosAndLossRadial(float src_lat, float src_lon, float src_alt, boost::python::list& dest_lat_arr, boost::python::list& dest_lon_arr, float dest_alt, float freq, int masl, int nof_processes, int justLos, int nofPointsPerRay, int stopAtFirstLoS);

  void setLatLonBoundaries(float minlat, float maxlat, float minlon, float maxlon);
  
  // heavy init: ie all necessary params are inittialized and the DEM is loaded into memory
  void initialize_heavy(int min_lat, int max_lat, int min_lon, int max_lon, float diel_const, float earth_cond, float at_bend, float radio_climate,float pol,float frac_of_situ,float frac_of_time,float ground_clutter);

  // light init: ie all necessary params are initialized but the DEM is NOT loaded into memory
  void initialize_light( float diel_const, float earth_cond, float at_bend, float radio_climate,float pol,float frac_of_situ,float frac_of_time,float ground_clutter);

  short getElevationAtLoc(float lat, float lon); // this will load the necessary DEM
  short getElevationAtLocWithoutLoadingDEM(float lat, float lon); // this will NOT load the necessary DEM

  void freeDemSharedMemory();
};





#endif
